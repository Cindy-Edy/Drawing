<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <!-- Crucial viewport settings for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Keyzia Draw - Aplikasi Mewarnai</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
        integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#5cb85c">
    

    <script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw1.js')
    .then(function(registration) {
      console.log('Service Worker terdaftar:', registration);
    })
    .catch(function(error) {
      console.log('Pendaftaran Service Worker gagal:', error);
    });
}
    </script>
    
    <style>
        :root {
            --primary-color: #5cb85c;
            --primary-hover-color: #4cae4c;
            --active-tool-bg: #e0e0e0;
            --dropdown-bg: rgba(255, 255, 255, 0.95); /* Slightly more opaque */
            --text-color: #333;
            --border-color: #777;
            --grid-color: #ccc;
        }

        /* Prevent scrolling and ensure full height */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Absolutely prevent body scroll */
            position: fixed; /* Prevent any scroll */
            width: 100%;
            overscroll-behavior: none; /* Prevent pull-to-refresh/overscroll effects */
        }

        body {
            text-align: center;
            background: linear-gradient(135deg, #a8edea, #fed6e3);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
        }

        h1 {
            color: var(--text-color);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
            margin-top: 10px;
            margin-bottom: 5px; /* Reduced margin */
            font-size: 1.8em;
            flex-shrink: 0; /* Prevent h1 from shrinking */
        }

        /* Dropdown container */
        .options-dropdown {
            position: absolute;
            top: 10px;
            right: 10px;
            display: inline-block;
            z-index: 1000; /* Ensure dropdown button is on top */
        }

        /* Dropdown button */
        .options-button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border: none;
            cursor: pointer;
            border-radius: 8px;
            font-size: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease;
        }
        .options-button:hover {
            background-color: var(--primary-hover-color);
        }
        /* Keep dropdown content accessible via focus/keyboard */
        .options-button:focus + .options-content,
        .options-dropdown:hover .options-content {
            display: block;
            opacity: 1;
            visibility: visible;
        }

        /* Dropdown content area */
        .options-content {
            /* display: none; Controlled by hover/focus */
            opacity: 0; /* Start hidden */
            visibility: hidden; /* Start hidden */
            transition: opacity 0.2s ease, visibility 0.2s ease; /* Smooth transition */
            position: absolute;
            background-color: var(--dropdown-bg);
            backdrop-filter: blur(3px); /* Optional blur effect */
            min-width: 230px; /* Adjusted width */
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            padding: 12px; /* Slightly more padding */
            z-index: 999; /* Below button but above canvas */
            border-radius: 10px;
            right: 0;
            text-align: left;
            max-height: calc(100vh - 80px); /* Limit height more reliably */
            overflow-y: auto; /* Add scroll if needed */
            border: 1px solid rgba(0,0,0,0.1);
        }


        /* Item spacing and dividers */
        .dropdown-item {
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        .dropdown-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .dropdown-item label {
            display: block;
            margin-bottom: 5px; /* Slightly more space */
            color: var(--text-color);
            font-weight: bold;
            font-size: 14px;
        }
        .dropdown-item label i { margin-right: 6px; width: 16px; text-align: center; }

        /* Consistent styling for controls */
        .dropdown-tool-button,
        .dropdown-range-input {
            display: block;
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 5px;
            border: 1px solid transparent;
            background-color: transparent;
            text-align: left;
            cursor: pointer;
            border-radius: 5px;
            font-size: 15px;
            color: var(--text-color);
            transition: background-color 0.2s ease, border-color 0.2s ease;
            box-sizing: border-box; /* Include padding in width */
        }
        .dropdown-tool-button {
             display: flex; /* Align icon and text */
             align-items: center;
             gap: 8px;
        }
         .dropdown-tool-button i:first-child {
             width: 18px; /* Consistent icon width */
             text-align: center;
             color: #555;
         }


        .dropdown-tool-button:hover {
            background-color: #e9e9e9;
        }
        .dropdown-tool-button.active-tool {
            background-color: var(--active-tool-bg);
            border-color: #bbb;
            font-weight: bold;
            color: #000;
        }
         .dropdown-tool-button.active-tool i:first-child {
             color: var(--primary-color); /* Highlight active icon */
         }
         .dropdown-tool-button:disabled { /* Style for disabled */
             opacity: 0.5;
             cursor: not-allowed;
             background-color: #f0f0f0;
         }


        .dropdown-color-picker {
            display: block;
            height: 35px;
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 0;
            cursor: pointer;
            box-sizing: border-box;
            margin-bottom: 5px; /* Align with other controls */
        }
        .dropdown-color-picker::-webkit-color-swatch-wrapper { padding: 2px; }
        .dropdown-color-picker::-webkit-color-swatch { border: none; border-radius: 3px; }


        .dropdown-range-input {
            width: 100%;
            cursor: pointer;
            margin-top: 3px; /* Space below label */
        }

        .range-value {
            font-size: 13px;
            color: #555;
            margin-left: 8px; /* Space between label text and value */
            font-weight: normal;
        }

        /* Color Palette */
        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px; /* Space above palette */
            padding-bottom: 5px; /* Space below palette */
        }

        .palette-color {
            width: 22px; /* Slightly larger */
            height: 22px;
            border-radius: 50%;
            border: 1px solid #bbb;
            cursor: pointer;
            display: inline-block;
            box-shadow: 0 0 3px rgba(0,0,0,0.1);
            transition: transform 0.1s ease;
        }
        .palette-color:hover { transform: scale(1.15); }

        /* Brush Types Grouping */
        .brush-types {
             /* Remove border/padding, handled by dropdown-item */
             margin-top: 0;
        }
         .brush-types label { /* Already styled by dropdown-item label */
            margin-bottom: 5px;
         }

        /* Canvas Styling */
        #drawingCanvas {
            border: 4px solid var(--border-color);
            background: white;
            border-radius: 12px;
            cursor: crosshair; /* Default cursor */
            box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);
            margin: 10px auto; /* Center horizontally */
            display: block;
            flex-grow: 1; /* Allow canvas to take available vertical space */
            max-width: calc(100% - 20px); /* Prevent touching edges, accounts for margin */
            max-height: calc(100% - 60px); /* Approx height accounting for H1 and margins */
            box-sizing: border-box; /* Include border in size calculation */
            touch-action: none; /* VERY IMPORTANT: Prevent default touch actions like scrolling/zooming */
        }

        /* Hide the file input */
        #imageUpload { display: none; }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            h1 { font-size: 1.5em; }
            .options-button { padding: 8px 12px; font-size: 14px; }
            .options-content { min-width: 200px; max-height: calc(100vh - 70px); }
            .dropdown-tool-button, .dropdown-range-input { font-size: 14px; }
            #drawingCanvas { max-width: calc(100% - 10px); margin: 5px auto; }
        }

        @media screen and (orientation: landscape) and (max-height: 500px) {
             h1 { margin-top: 5px; font-size: 1.3em; }
             .options-dropdown { top: 5px; right: 5px; }
             .options-content { max-height: calc(100vh - 50px); }
             #drawingCanvas { max-height: calc(100% - 45px); }
        }
    </style>
</head>

<body>
    <h1>Keyzia Draw - Mari Berkreasi!</h1>

    <div class="options-dropdown">
        <button class="options-button" aria-haspopup="true" aria-expanded="false" aria-controls="optionsMenu"><i class="fas fa-cog"></i> Opsi</button>
        <div class="options-content" id="optionsMenu" role="menu">
            <!-- Color Section -->
            <div class="dropdown-item" role="menuitem">
                <label for="colorPicker"><i class="fas fa-palette"></i> Warna:</label>
                <input type="color" id="colorPicker" class="dropdown-color-picker" value="#000000" title="Pilih Warna">
                <div class="color-palette" id="colorPalette">
                    <!-- Palette colors will be added by JS -->
                </div>
            </div>

            <!-- Size Section -->
            <div class="dropdown-item" role="menuitem">
                <label for="penSize"><i class="fas fa-paint-brush"></i> Ukuran Kuas: <span id="penSizeValue" class="range-value">5</span></label>
                <input type="range" id="penSize" class="dropdown-range-input" min="1" max="50" value="5" title="Ukuran Kuas">
            </div>
            <div class="dropdown-item" role="menuitem">
                <label for="eraserSize"><i class="fas fa-eraser"></i> Ukuran Penghapus: <span id="eraserSizeValue" class="range-value">10</span></label>
                <input type="range" id="eraserSize" class="dropdown-range-input" min="1" max="100" value="10" title="Ukuran Penghapus">
            </div>

             <!-- Tools Section -->
             <div class="dropdown-item" role="menuitem">
                 <label><i class="fas fa-tools"></i> Alat:</label>
                 <button class="dropdown-tool-button" id="brushButton" title="Kuas (B)"><i class="fas fa-paint-brush"></i> Kuas</button>
                 <button class="dropdown-tool-button" id="eraserButton" title="Penghapus (E)"><i class="fas fa-eraser"></i> Penghapus</button>
                 <button class="dropdown-tool-button" id="fillButton" title="Isi Warna (F)"><i class="fas fa-fill-drip"></i> Isi Warna</button>
             </div>

            <!-- Brush Types Section -->
            <div class="dropdown-item brush-types" role="menuitem">
                <label><i class="fas fa-shapes"></i> Jenis Kuas:</label>
                <button class="dropdown-tool-button" data-brush="basic"><i class="fas fa-pencil-alt"></i> Dasar</button>
                <button class="dropdown-tool-button" data-brush="circle"><i class="fas fa-circle"></i> Lingkaran</button>
                <button class="dropdown-tool-button" data-brush="square"><i class="fas fa-square"></i> Kotak</button>
                <button class="dropdown-tool-button" data-brush="spray"><i class="fas fa-spray-can"></i> Semprot</button>
                <button class="dropdown-tool-button" data-brush="heart"><i class="fas fa-heart"></i> Hati</button>
                <button class="dropdown-tool-button" data-brush="star"><i class="fas fa-star"></i> Bintang</button>
                <button class="dropdown-tool-button" data-brush="flower"><i class="fas fa-fan"></i> Bunga</button>
                <button class="dropdown-tool-button" data-brush="leaf"><i class="fas fa-leaf"></i> Daun</button>
                <button class="dropdown-tool-button" data-brush="diamond"><i class="fas fa-gem"></i> Berlian</button>
            </div>

            <!-- Actions Section -->
            <div class="dropdown-item" role="menuitem">
                 <label><i class="fas fa-cogs"></i> Tindakan:</label>
                <button class="dropdown-tool-button" id="undoButton" title="Undo (Ctrl+Z)" disabled><i class="fas fa-undo"></i> Undo</button>
                <button class="dropdown-tool-button" id="redoButton" title="Redo (Ctrl+Y)" disabled><i class="fas fa-redo"></i> Redo</button>
                <button class="dropdown-tool-button" id="gridButton" title="Grid (G)"><i class="fas fa-border-all"></i> Grid</button>
                <button class="dropdown-tool-button" id="clearButton" title="Bersihkan"><i class="fas fa-trash"></i> Bersihkan</button>
                 <label style="margin-top: 10px;"><i class="fas fa-file-alt"></i> File:</label> <!-- File label -->
                <button class="dropdown-tool-button" id="saveButton" title="Simpan (Ctrl+S)"><i class="fas fa-save"></i> Simpan PNG</button>
                <button class="dropdown-tool-button" id="uploadButton" title="Unggah Gambar"><i class="fas fa-upload"></i> Unggah</button>
                <input type="file" id="imageUpload" accept="image/*">
                <button class="dropdown-tool-button" id="shareButton" title="Bagikan"><i class="fas fa-share-alt"></i> Bagikan</button>
            </div>
        </div>
    </div>

    <canvas id="drawingCanvas" aria-label="Kanvas untuk menggambar"></canvas>

    <script>
        "use strict"; // Enable strict mode

        // === DOM Elements ===
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d', {
            willReadFrequently: true // Needed for flood fill performance
            // desynchronized: true // Can improve latency on some browsers, test carefully
        });

        // Dropdown Controls
        const colorPicker = document.getElementById('colorPicker');
        const penSizeSlider = document.getElementById('penSize');
        const eraserSizeSlider = document.getElementById('eraserSize');
        const penSizeValueSpan = document.getElementById('penSizeValue');
        const eraserSizeValueSpan = document.getElementById('eraserSizeValue');
        const brushButton = document.getElementById('brushButton');
        const eraserButton = document.getElementById('eraserButton');
        const fillButton = document.getElementById('fillButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const clearButton = document.getElementById('clearButton');
        const gridButton = document.getElementById('gridButton');
        const saveButton = document.getElementById('saveButton');
        const uploadButton = document.getElementById('uploadButton');
        const imageUploadInput = document.getElementById('imageUpload');
        const shareButton = document.getElementById('shareButton');
        const colorPaletteContainer = document.getElementById('colorPalette');
        const brushTypeButtons = document.querySelectorAll('.brush-types .dropdown-tool-button[data-brush]');

        // === State ===
        const state = {
            isDrawing: false,
            currentTool: 'brush', // 'brush', 'eraser', 'fill'
            lastX: 0, // Stores last position in CSS pixels
            lastY: 0, // Stores last position in CSS pixels
            color: '#000000',
            penSize: 5, // In CSS pixels
            eraserSize: 10, // In CSS pixels
            brushType: 'basic',
            gridEnabled: false,
            history: [],
            historyStep: -1,
            maxHistory: 30,
            dpr: window.devicePixelRatio || 1,
        };

        // --- Initialization ---
        function initializeApp() {
            console.log("Keyzia Draw Initializing...");
             // Initial state from HTML elements
            state.color = colorPicker.value;
            state.penSize = parseInt(penSizeSlider.value, 10);
            state.eraserSize = parseInt(eraserSizeSlider.value, 10);
            penSizeValueSpan.textContent = state.penSize;
            eraserSizeValueSpan.textContent = state.eraserSize;
            state.dpr = window.devicePixelRatio || 1;

            createColorPalette();
            resizeCanvas(); // Initial resize & context scaling
            setupEventListeners();
            updateToolUI(); // Set initial active tool UI
            saveHistory(); // Save initial blank state
            console.log("Keyzia Draw Initialized. DPR:", state.dpr);
        }

        function createColorPalette() {
            const defaultColors = [
                '#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00',
                '#FF00FF', '#00FFFF', '#FFA500', '#800080', '#008000', '#8B4513',
                '#E91E63', '#9C27B0', '#3F51B5', '#03A9F4', '#009688', '#8BC34A',
                '#FFEB3B', '#FF9800', '#795548', '#607D8B'
            ];
            colorPaletteContainer.innerHTML = ''; // Clear previous palette
            defaultColors.forEach(c => {
                const colorDiv = document.createElement('div');
                colorDiv.classList.add('palette-color');
                colorDiv.style.backgroundColor = c;
                colorDiv.title = `Pilih ${c}`;
                colorDiv.setAttribute('aria-label', `Pilih warna ${c}`);
                colorDiv.addEventListener('click', () => {
                    colorPicker.value = c;
                    state.color = c; // Update global state
                });
                colorPaletteContainer.appendChild(colorDiv);
            });
        }

        // --- Canvas Setup and Drawing ---

        function resizeCanvas() {
            console.log("Resizing canvas...");
            state.dpr = window.devicePixelRatio || 1; // Update DPR

            // Get the available space for the canvas based on its parent/CSS
            // Use body client dimensions as a fallback for initial sizing if needed
            const containerRect = canvas.parentElement.getBoundingClientRect();
            const cssWidth = canvas.clientWidth || containerRect.width - 20; // Use actual rendered width if available
            const cssHeight = canvas.clientHeight || containerRect.height - 60; // Use actual rendered height if available

            // Set the canvas buffer size (actual pixels)
            canvas.width = Math.round(cssWidth * state.dpr);
            canvas.height = Math.round(cssHeight * state.dpr);

            // Set the display size (CSS pixels)
            canvas.style.width = `${cssWidth}px`;
            canvas.style.height = `${cssHeight}px`;

            // Scale the context ONCE for all drawing operations
            ctx.scale(state.dpr, state.dpr);

            console.log(`Canvas resized: Buffer(${canvas.width}x${canvas.height}), CSS(${cssWidth}x${cssHeight}), DPR(${state.dpr})`);

            // Redraw content after resizing and scaling
            redrawHistory();
        }

        /**
         * Gets pointer position relative to the canvas element in CSS pixels.
         */
        function getPos(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX = 0, clientY = 0;

            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.clientX !== undefined) {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const cssX = clientX - rect.left;
            const cssY = clientY - rect.top;
            // console.log(`getPos: Client(${clientX.toFixed(1)}, ${clientY.toFixed(1)}), Rect(${rect.left.toFixed(1)}, ${rect.top.toFixed(1)}), Result CSS(${cssX.toFixed(1)}, ${cssY.toFixed(1)})`);
            return { x: cssX, y: cssY };
        }

        /**
         * Core drawing function. Operates in CSS pixels.
         */
        function draw(x, y) {
             if (!state.isDrawing) return;

             const currentSize = (state.currentTool === 'eraser' ? state.eraserSize : state.penSize);
             const lastCssX = state.lastX;
             const lastCssY = state.lastY;

             ctx.lineCap = 'round';
             ctx.lineJoin = 'round';

             if (state.currentTool === 'eraser') {
                 ctx.globalCompositeOperation = 'destination-out'; // Erase mode
                 ctx.lineWidth = currentSize; // Use CSS pixel size
                 ctx.beginPath();
                 ctx.moveTo(lastCssX, lastCssY);
                 ctx.lineTo(x, y);
                 ctx.stroke();
             } else { // 'brush' tool
                 ctx.globalCompositeOperation = 'source-over'; // Normal drawing mode
                 ctx.strokeStyle = state.color;
                 ctx.fillStyle = state.color;
                 ctx.lineWidth = currentSize; // Use CSS pixel size

                 switch (state.brushType) {
                     case 'circle':
                         ctx.beginPath();
                         ctx.arc(x, y, currentSize / 2, 0, 2 * Math.PI);
                         ctx.fill();
                         break;
                     case 'square':
                         ctx.fillRect(x - currentSize / 2, y - currentSize / 2, currentSize, currentSize);
                         break;
                     case 'spray':
                         const density = 30;
                         for (let i = 0; i < density; i++) {
                             const angle = Math.random() * Math.PI * 2;
                             const radius = Math.random() * currentSize / 1.5;
                             // Draw 1x1 CSS pixel rects (scaled by context)
                             ctx.fillRect(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius, 1, 1);
                         }
                         break;
                    case 'heart': drawHeart(x, y, currentSize); break;
                    case 'star': drawStar(x, y, currentSize); break;
                    case 'flower': drawFlower(x, y, currentSize); break;
                    case 'leaf': drawLeaf(x, y, currentSize); break;
                    case 'diamond': drawDiamond(x, y, currentSize); break;
                     case 'basic':
                     default:
                         ctx.beginPath();
                         ctx.moveTo(lastCssX, lastCssY);
                         ctx.lineTo(x, y);
                         ctx.stroke();
                         break;
                 }
             }

             // Update last position (in CSS pixels)
             state.lastX = x;
             state.lastY = y;
        }

        // --- Shape Drawing Helpers (operate using CSS pixel coords provided by draw()) ---
        function drawHeart(x, y, size) {
            ctx.save(); ctx.fillStyle = state.color; ctx.beginPath(); const t=y-size*.3,b=y+size*.7,w=size*1.1,c1x=x+w*.5,c1y=y-size*.6,c2x=x-w*.5,c2y=y-size*.6; ctx.moveTo(x,t); ctx.bezierCurveTo(x,c1y,c1x,c1y,c1x,y); ctx.bezierCurveTo(c1x,y+size*.4,x,b,x,b); ctx.bezierCurveTo(x,b,c2x,y+size*.4,c2x,y); ctx.bezierCurveTo(c2x,c2y,x,c2y,x,t); ctx.closePath(); ctx.fill(); ctx.restore();
        }
        function drawStar(x, y, size) {
            ctx.save(); ctx.fillStyle = state.color; ctx.translate(x,y); ctx.beginPath(); ctx.moveTo(0,-size/2); for(let i=0;i<5;i++){ ctx.rotate(Math.PI/5); ctx.lineTo(0,-(size/4)); ctx.rotate(Math.PI/5); ctx.lineTo(0,-size/2); } ctx.closePath(); ctx.fill(); ctx.restore();
        }
        function drawFlower(x, y, size) {
            ctx.save(); ctx.fillStyle = state.color; ctx.translate(x,y); ctx.beginPath(); const n=6,r=size/3,a=(Math.PI*2)/n; for(let i=0;i<n;i++){ const px=Math.cos(a*i)*r*.8,py=Math.sin(a*i)*r*.8; ctx.moveTo(px+r,py); ctx.arc(px,py,r,0,Math.PI*2); } ctx.fill(); ctx.restore();
        }
        function drawLeaf(x, y, size) {
             ctx.save(); ctx.fillStyle = state.color; ctx.translate(x,y); ctx.rotate(Math.PI/4); const w=size*.8,h=size*.4; ctx.beginPath(); ctx.ellipse(0,0,w/2,h/2,0,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
        function drawDiamond(x, y, size) {
             ctx.save(); ctx.fillStyle = state.color; ctx.translate(x,y); ctx.beginPath(); ctx.moveTo(0,-size/2); ctx.lineTo(size/2.5,0); ctx.lineTo(0,size/2); ctx.lineTo(-size/2.5,0); ctx.closePath(); ctx.fill(); ctx.restore();
        }


        // --- Fill Tool ---
        function floodFill(startX, startY) {
             console.log(`Fill starting at CSS(${startX.toFixed(1)}, ${startY.toFixed(1)})`);
             // Convert CSS start point to Canvas buffer coordinates
             const canvasX = Math.floor(startX * state.dpr);
             const canvasY = Math.floor(startY * state.dpr);
             const canvasWidth = canvas.width;
             const canvasHeight = canvas.height;

             // Boundary check (using canvas buffer coords)
             if (canvasX < 0 || canvasX >= canvasWidth || canvasY < 0 || canvasY >= canvasHeight) {
                 console.log("Fill start point out of bounds.");
                 return false;
             }

             let imageData;
             try {
                 imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
             } catch (e) {
                 console.error("floodFill: Failed to getImageData.", e);
                 alert("Tidak dapat mengisi warna (mungkin karena gambar eksternal).");
                 return false;
             }

             const data = imageData.data;
             const targetColor = getPixelColor(data, canvasWidth, canvasX, canvasY); // Color at canvas coords
             const fillColorRgb = hexToRgb(state.color);

             if (!fillColorRgb) { console.error("Invalid fill color:", state.color); return false; }
             if (colorsMatch(targetColor, fillColorRgb)) { console.log("Target matches fill color."); return false; }

             const stack = [[canvasX, canvasY]]; // Stack uses canvas coords
             const visited = new Set();
             let iterations = 0;
             const maxIterations = canvasWidth * canvasHeight; // Safety limit

             while (stack.length > 0) {
                 iterations++;
                 if (iterations > maxIterations) {
                     console.error("Fill tool reached max iterations.");
                     alert("Area terlalu kompleks untuk diisi.");
                     return false;
                 }

                 const [x, y] = stack.pop(); // Current canvas coords
                 const pixelKey = `${x},${y}`;

                 // Bounds, visited, and color match checks (using canvas coords)
                 if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight || visited.has(pixelKey)) continue;
                 const currentColor = getPixelColor(data, canvasWidth, x, y);
                 if (!colorsMatch(currentColor, targetColor)) continue;

                 // Color pixel, mark visited, add neighbors (using canvas coords)
                 setPixelColor(data, canvasWidth, x, y, fillColorRgb);
                 visited.add(pixelKey);
                 stack.push([x + 1, y]); stack.push([x - 1, y]);
                 stack.push([x, y + 1]); stack.push([x, y - 1]);
             }

             ctx.putImageData(imageData, 0, 0);
             console.log(`Fill complete: ${visited.size} pixels filled.`);
             return true; // Success
         }
        // Fill Helpers (operate on raw image data & canvas pixel coords)
        function getPixelColor(d,w,x,y){ const i=(y*w+x)*4; return [d[i],d[i+1],d[i+2],d[i+3]]; }
        function setPixelColor(d,w,x,y,c){ const i=(y*w+x)*4; d[i]=c.r; d[i+1]=c.g; d[i+2]=c.b; d[i+3]=c.a??255; }
        function colorsMatch(c1,c2){ const t=10; return Math.abs(c1[0]-c2.r)<=t && Math.abs(c1[1]-c2.g)<=t && Math.abs(c1[2]-c2.b)<=t && Math.abs(c1[3]-(c2.a??255))<=t; }
        function hexToRgb(h){ h=h.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,(m,r,g,b)=>r+r+g+g+b+b); const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h); return r?{r:parseInt(r[1],16),g:parseInt(r[2],16),b:parseInt(r[3],16),a:255}:null; }


        // --- History Management ---
        function saveHistory() {
            // Clear redo steps if we draw/fill after undoing
            if (state.historyStep < state.history.length - 1) {
                state.history.length = state.historyStep + 1;
            }

            // Manage history limit
            if (state.history.length >= state.maxHistory) {
                state.history.shift(); // Remove oldest
                // Do not decrement historyStep, it effectively stays at max-1
            } else {
                state.historyStep++;
            }

            try {
                 // Save state from the main canvas
                state.history[state.historyStep] = canvas.toDataURL('image/png');
                updateUndoRedoButtons();
                // console.log(`History saved. Step: ${state.historyStep}, Length: ${state.history.length}`);
            } catch (error) {
                 console.error("Failed to save history (tainted canvas?):", error);
                 // Attempt to revert history step if save failed
                 if (state.historyStep > 0 && state.history.length <= state.historyStep) {
                     state.historyStep--;
                 } else if (state.history.length >= state.maxHistory) {
                      state.historyStep = Math.min(state.historyStep, state.history.length - 1);
                 }
                 alert("Gagal menyimpan langkah undo.");
                 updateUndoRedoButtons();
            }
        }

        function undo() {
            if (state.historyStep > 0) {
                state.historyStep--;
                redrawFromHistory(state.historyStep);
                console.log(`Undo to step ${state.historyStep}`);
            }
        }

        function redo() {
            if (state.historyStep < state.history.length - 1) {
                state.historyStep++;
                redrawFromHistory(state.historyStep);
                console.log(`Redo to step ${state.historyStep}`);
            }
        }

        function redrawFromHistory(step) {
             if (step < 0 || step >= state.history.length || !state.history[step]) {
                 console.warn(`Invalid history step (${step}) or data missing. Clearing canvas.`);
                 // Clear using CSS dimensions as context is scaled
                 const cssWidth = canvas.width / state.dpr;
                 const cssHeight = canvas.height / state.dpr;
                 ctx.clearRect(0, 0, cssWidth, cssHeight);
                  if (step < 0) state.historyStep = -1; // Reset if trying to go before start
                  updateUndoRedoButtons(); // Update buttons after clearing
                 return;
             }

             let img = new Image();
             img.onload = () => {
                 // Clear canvas first using CSS dimensions
                 const cssWidth = canvas.width / state.dpr;
                 const cssHeight = canvas.height / state.dpr;
                 ctx.clearRect(0, 0, cssWidth, cssHeight);
                 // Draw history image using CSS dimensions onto the scaled context
                 ctx.drawImage(img, 0, 0, cssWidth, cssHeight);
                 // Redraw grid AFTER history image if enabled
                 if (state.gridEnabled) drawGrid();
                 console.log(`Redrawn from history step ${step}`);
                 updateUndoRedoButtons(); // Update buttons after successful redraw
             };
             img.onerror = () => console.error(`Failed to load history image for step ${step}`);
             img.src = state.history[step];
         }

        // Redraw the *current* history state (used mainly during resize)
        function redrawHistory() {
            redrawFromHistory(state.historyStep);
        }

        function updateUndoRedoButtons() {
             undoButton.disabled = state.historyStep <= 0;
             redoButton.disabled = state.historyStep >= state.history.length - 1;
        }

        // --- Grid ---
        function drawGrid() {
            if (!state.gridEnabled) return;
             // Draw grid based on CSS pixel dimensions
             const cssWidth = canvas.width / state.dpr;
             const cssHeight = canvas.height / state.dpr;
             const gridSize = 30; // Grid size in CSS pixels

            ctx.save();
            ctx.strokeStyle = 'var(--grid-color)';
            ctx.lineWidth = 1 / state.dpr; // Aim for 1 device pixel width lines
            ctx.globalCompositeOperation = 'source-over'; // Ensure grid draws on top
            // ctx.setLineDash([2, 2]); // Optional dashed lines

            for (let x = gridSize; x < cssWidth; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, cssHeight); ctx.stroke();
            }
            for (let y = gridSize; y < cssHeight; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(cssWidth, y); ctx.stroke();
            }
            ctx.restore();
        }

        // --- UI Updates ---
        function updateToolUI() {
             // Remove active state from all tool buttons
             brushButton.classList.remove('active-tool');
             eraserButton.classList.remove('active-tool');
             fillButton.classList.remove('active-tool');
             gridButton.classList.remove('active-tool'); // Grid is independent but update visual state
             brushTypeButtons.forEach(btn => btn.classList.remove('active-tool'));

             // Set active state for the current tool
             let cursorStyle = 'crosshair'; // Default to brush cursor
             if (state.currentTool === 'brush') {
                 brushButton.classList.add('active-tool');
                 // Also highlight the specific brush type button
                 const activeBrushTypeButton = document.querySelector(`.brush-types .dropdown-tool-button[data-brush="${state.brushType}"]`);
                 if (activeBrushTypeButton) activeBrushTypeButton.classList.add('active-tool');
             } else if (state.currentTool === 'eraser') {
                 eraserButton.classList.add('active-tool');
                 cursorStyle = 'cell'; // Or specific eraser cursor
             } else if (state.currentTool === 'fill') {
                 fillButton.classList.add('active-tool');
                 cursorStyle = 'copy';
             }

             // Update grid button visual state
             if (state.gridEnabled) {
                 gridButton.classList.add('active-tool');
             }

             canvas.style.cursor = cursorStyle;
             console.log("UI Updated. Tool:", state.currentTool, "Brush:", state.brushType, "Grid:", state.gridEnabled);
        }


        // --- Event Handlers ---
        function handleStart(e) {
             if (e.type.startsWith('touch')) e.preventDefault(); // Prevent scroll/zoom etc.

             const { x, y } = getPos(e); // Get position in CSS pixels

             if (state.currentTool === 'fill') {
                 // Execute fill on click/tap start
                 if (floodFill(x, y)) {
                     saveHistory(); // Save state only if fill actually happened
                 }
                 // Note: Fill tool remains active until another tool is selected
             } else {
                 // Start drawing or erasing
                 state.isDrawing = true;
                 state.lastX = x;
                 state.lastY = y;
                 // Draw initial shape/dot for non-line brushes immediately
                 if (state.currentTool === 'brush' && state.brushType !== 'basic') {
                     draw(x, y);
                 }
                 // Save history at the beginning of a stroke/erase action
                 saveHistory();
             }
        }

        function handleMove(e) {
            if (e.type.startsWith('touch')) e.preventDefault();

            // Only draw if dragging and not in fill mode
            if (!state.isDrawing || state.currentTool === 'fill') return;

            const { x, y } = getPos(e);
            draw(x, y);
            // History is saved at the start of the stroke in handleStart
        }

        function handleEnd(e) {
             if (e.type.startsWith('touch')) e.preventDefault();
            if (state.isDrawing) {
                state.isDrawing = false;
                // Optional: Reset path to prevent potential stray line on next mousedown after mouseout/up
                // ctx.beginPath();
            }
        }

        // Handle tool selection
        function handleToolChange(newTool) {
            if (state.currentTool === newTool) return; // No change
            state.currentTool = newTool;
            state.isDrawing = false; // Stop any drawing if tool changes mid-drag
            updateToolUI();
        }

        // Handle brush type selection
        function handleBrushTypeChange(newType) {
             if (!newType) return;
             state.brushType = newType;
             // Automatically switch to brush tool when a brush type is selected
             state.currentTool = 'brush';
             updateToolUI();
             console.log(`Brush type changed to: ${newType}`);
        }


        // --- Setup Event Listeners ---
        function setupEventListeners() {
            // Canvas Mouse events
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('mouseleave', handleEnd); // Stop drawing if mouse leaves

            // Canvas Touch events (passive: false allows preventDefault)
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            canvas.addEventListener('touchend', handleEnd, { passive: false });
            canvas.addEventListener('touchcancel', handleEnd, { passive: false });

            // --- Dropdown Controls ---
            colorPicker.addEventListener('change', (e) => { state.color = e.target.value; }); // Update state directly
            penSizeSlider.addEventListener('input', (e) => {
                state.penSize = parseInt(e.target.value, 10);
                penSizeValueSpan.textContent = state.penSize;
            });
            eraserSizeSlider.addEventListener('input', (e) => {
                state.eraserSize = parseInt(e.target.value, 10);
                eraserSizeValueSpan.textContent = state.eraserSize;
            });

             // Tool selection buttons
             brushButton.addEventListener('click', () => handleToolChange('brush'));
             eraserButton.addEventListener('click', () => handleToolChange('eraser'));
             fillButton.addEventListener('click', () => handleToolChange('fill'));

            // Brush type buttons (using data attributes)
             brushTypeButtons.forEach(button => {
                 const type = button.dataset.brush;
                 if (type) {
                     button.addEventListener('click', () => handleBrushTypeChange(type));
                 }
             });

            // Action buttons
            undoButton.addEventListener('click', undo);
            redoButton.addEventListener('click', redo);
            clearButton.addEventListener('click', () => {
                 if (confirm('Anda yakin ingin membersihkan seluruh kanvas?')) {
                    const cssWidth = canvas.width / state.dpr;
                    const cssHeight = canvas.height / state.dpr;
                    ctx.clearRect(0, 0, cssWidth, cssHeight);
                    saveHistory(); // Save the cleared state
                    if (state.gridEnabled) drawGrid(); // Redraw grid if needed
                 }
            });
            gridButton.addEventListener('click', () => {
                state.gridEnabled = !state.gridEnabled;
                redrawHistory(); // Redraw current state (will include/exclude grid draw)
                updateToolUI(); // Update button highlight
            });

            // --- File Operations (with clean export using temp canvas) ---
            saveButton.addEventListener('click', async () => {
                if (state.historyStep < 0 || !state.history[state.historyStep]) {
                    alert("Tidak ada gambar untuk disimpan."); return;
                }
                try {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    const img = new Image();
                    await new Promise((resolve, reject) => {
                        img.onload = resolve; img.onerror = reject;
                        img.src = state.history[state.historyStep]; // Load current clean history state
                    });
                    tempCanvas.width = canvas.width; // Match buffer resolution
                    tempCanvas.height = canvas.height;
                    tempCtx.drawImage(img, 0, 0); // Draw history image to temp canvas

                    const dataURL = tempCanvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.href = dataURL;
                    link.download = 'keyzia-drawing.png';
                    link.click();
                    console.log("Image save initiated.");
                } catch (e) {
                    console.error("Save error:", e); alert("Gagal menyimpan gambar.");
                }
            });

            uploadButton.addEventListener('click', () => imageUploadInput.click());
            imageUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file || !file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                         const cssWidth = canvas.width / state.dpr;
                         const cssHeight = canvas.height / state.dpr;
                         ctx.clearRect(0, 0, cssWidth, cssHeight); // Clear first
                         // Draw image centered and scaled to fit
                         const hRatio = cssWidth / img.width;
                         const vRatio = cssHeight / img.height;
                         const ratio = Math.min(hRatio, vRatio);
                         const centerShiftX = (cssWidth - img.width * ratio) / 2;
                         const centerShiftY = (cssHeight - img.height * ratio) / 2;
                         ctx.drawImage(img, 0, 0, img.width, img.height,
                                       centerShiftX, centerShiftY, img.width * ratio, img.height * ratio);
                         saveHistory(); // Save uploaded image state
                         if (state.gridEnabled) drawGrid();
                         console.log("Image uploaded and drawn.");
                    };
                    img.onerror = () => { alert("Gagal memuat gambar yang diunggah."); console.error("Uploaded image load error."); };
                    img.src = ev.target.result;
                };
                reader.onerror = () => { alert("Gagal membaca file."); console.error("File reader error."); };
                reader.readAsDataURL(file);
                e.target.value = null; // Reset input
            });

            shareButton.addEventListener('click', async () => {
                 if (!navigator.share) {
                    alert('Fitur bagikan tidak didukung di browser ini. Coba simpan gambar.');
                    saveButton.click(); return;
                 }
                 if (state.historyStep < 0 || !state.history[state.historyStep]) {
                     alert("Tidak ada gambar untuk dibagikan."); return;
                 }
                try {
                    // Create blob from a clean temporary canvas
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    const img = new Image();
                    await new Promise((resolve, reject) => {
                        img.onload = resolve; img.onerror = reject;
                        img.src = state.history[state.historyStep];
                    });
                    tempCanvas.width = canvas.width; tempCanvas.height = canvas.height;
                    tempCtx.drawImage(img, 0, 0);

                    tempCanvas.toBlob(async (blob) => {
                        if (!blob) throw new Error("Gagal membuat Blob gambar.");
                        const file = new File([blob], 'keyzia-drawing.png', { type: 'image/png' });
                        const shareData = {
                            title: 'Kreasi Keyzia Draw',
                            text: 'Lihat gambar yang saya buat!',
                            files: [file],
                        };
                        if (navigator.canShare && navigator.canShare(shareData)) {
                            await navigator.share(shareData);
                            console.log('Image shared successfully.');
                        } else {
                             alert('Tidak dapat membagikan file ini. Coba bagikan teks saja atau simpan gambar.');
                             // Fallback: Try sharing text only?
                             // await navigator.share({ title: shareData.title, text: shareData.text });
                        }
                    }, 'image/png');
                } catch (e) {
                    console.error('Share error:', e);
                    alert(`Gagal berbagi: ${e.message}. Coba simpan gambar.`);
                    saveButton.click(); // Fallback to save
                }
            });

            // Keyboard Shortcuts
            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
                let handled = false;
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 'z': if (!undoButton.disabled) undo(); handled = true; break;
                        case 'y': if (!redoButton.disabled) redo(); handled = true; break;
                        case 's': saveButton.click(); handled = true; break;
                    }
                } else if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
                    switch (e.key.toLowerCase()) {
                        case 'b': handleToolChange('brush'); handled = true; break;
                        case 'e': handleToolChange('eraser'); handled = true; break;
                        case 'f': handleToolChange('fill'); handled = true; break;
                        case 'g': gridButton.click(); handled = true; break;
                    }
                }
                if (handled) e.preventDefault();
            });

            // Window resize listener (Debounced)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(resizeCanvas, 150);
            });

             // Prevent context menu on canvas
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            console.log("Event listeners attached.");
        }

        // --- Start the application ---
        window.addEventListener('DOMContentLoaded', initializeApp);

    </script>

    <script>
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;
  // Tampilkan tombol install jika mau
  const installBtn = document.createElement("button");
  installBtn.textContent = "Install Aplikasi";
  installBtn.style.position = "fixed";
  installBtn.style.bottom = "20px";
  installBtn.style.right = "20px";
  installBtn.style.zIndex = "10000";
  installBtn.style.padding = "10px";
  installBtn.style.background = "#5cb85c";
  installBtn.style.color = "#fff";
  installBtn.style.border = "none";
  installBtn.style.borderRadius = "5px";
  document.body.appendChild(installBtn);

  installBtn.addEventListener("click", () => {
    installBtn.remove();
    deferredPrompt.prompt();
    deferredPrompt.userChoice.then((choiceResult) => {
      if (choiceResult.outcome === 'accepted') {
        console.log('User accepted install');
      } else {
        console.log('User dismissed install');
      }
      deferredPrompt = null;
    });
  });
});
    </script>
    
</body>

</html>
